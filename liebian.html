<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>在途分货裂变（飞书风格·表格粘贴·XLSX）</title>

  <style>
    :root{
      --bg:#F5F6F7; --card:#FFFFFF; --text:#1F2329; --muted:#646A73; --line:#E5E6EB;
      --blue:#3370FF; --blue2:#2B5CFF; --shadow:0 8px 24px rgba(31,35,41,.06);
      --radius:12px; --font: ui-sans-serif, system-ui, -apple-system, "Segoe UI","PingFang SC","Microsoft YaHei", Arial;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family:var(--font)}
    .topbar{height:56px;display:flex;align-items:center;justify-content:space-between;padding:0 20px;background:#fff;border-bottom:1px solid var(--line);position:sticky;top:0;z-index:10}
    .brand{display:flex;gap:10px;align-items:center;font-weight:700}
    .dot{width:10px;height:10px;border-radius:50%;background:var(--blue)}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:5px 10px;border-radius:999px;background:#f0f4ff;color:var(--blue);border:1px solid rgba(51,112,255,.2);font-size:12px}
    .actions{display:flex;gap:10px;align-items:center}
    .container{max-width:1280px;margin:18px auto;padding:0 18px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:14px}
    .card{background:var(--card);border:1px solid var(--line);border-radius:var(--radius);box-shadow:var(--shadow);padding:14px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .field{display:flex;gap:8px;align-items:center}
    label{font-size:12px;color:var(--muted)}
    input[type="text"], select{border:1px solid var(--line);border-radius:10px;padding:10px 10px;font-size:13px;outline:none;background:#fff;transition:.15s}
    input[type="text"]:focus, select:focus{border-color:rgba(51,112,255,.55);box-shadow:0 0 0 3px rgba(51,112,255,.12)}
    .btn{border:1px solid var(--line);background:#fff;color:var(--text);padding:9px 12px;border-radius:10px;font-size:13px;cursor:pointer;transition:.15s;display:inline-flex;gap:8px;align-items:center}
    .btn:hover{border-color:#d0d3da;background:#fafafa}
    .btn.primary{background:var(--blue);border-color:var(--blue);color:#fff;font-weight:600}
    .btn.primary:hover{background:var(--blue2);border-color:var(--blue2)}
    .btn.danger{border-color:#ffd1d1;background:#fff5f5}
    .sub{font-size:12px;color:var(--muted);line-height:1.5;margin-top:6px}
    .ok{color:#067647} .warn{color:#B42318}
    .hr{height:1px;background:var(--line);margin:12px 0}
    .tabs{display:flex;gap:8px;margin-bottom:10px}
    .tab{padding:8px 10px;border-radius:10px;border:1px solid var(--line);background:#fff;font-size:13px;cursor:pointer}
    .tab.active{border-color:rgba(51,112,255,.5);box-shadow:0 0 0 3px rgba(51,112,255,.10)}
    .hidden{display:none !important}

    .sheet-toolbar{display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:8px}
    .sheet-wrap{border:1px solid var(--line);border-radius:12px;overflow:hidden;background:#fff}
    .sheet-scroll{max-height:340px;overflow:auto}
    table.sheet{width:100%;border-collapse:separate;border-spacing:0}
    table.sheet thead th{position:sticky;top:0;z-index:2;background:#FAFAFA;color:var(--muted);font-weight:600;font-size:12px;border-bottom:1px solid var(--line);padding:10px 10px;text-align:left;white-space:nowrap}
    table.sheet td{border-bottom:1px solid var(--line);border-right:1px solid var(--line);padding:0;vertical-align:top;background:#fff}
    table.sheet tr td:last-child{border-right:none}
    table.sheet tbody tr:last-child td{border-bottom:none}
    .cell{padding:9px 10px;min-height:18px;font-size:13px;outline:none;white-space:pre-wrap;word-break:break-word}
    .cell:focus{box-shadow: inset 0 0 0 2px rgba(51,112,255,.55);background:#F7F9FF}
    .footer-note{font-size:12px;color:var(--muted);margin-top:8px}
  </style>

  <!-- 离线导出XLSX：把 xlsx.full.min.js 放到 html 同目录 -->
  <script src="./xlsx.full.min.js"></script>
</head>

<body>
  <div class="topbar">
    <div class="brand"><span class="dot"></span>在途分货裂变 <span class="pill">飞书风格 · 表格粘贴 · 离线XLSX</span></div>
    <div class="actions">
      <button class="btn" id="btnLoadSample">载入示例</button>
      <button class="btn danger" id="btnClearAll">清空全部</button>
      <button class="btn primary" id="btnRun">生成裂变结果</button>
    </div>
  </div>

  <div class="container">
    <div class="card">
      <div class="row" style="justify-content:space-between">
        <div class="row">
          <div class="field">
            <label>优先级方向</label>
            <select id="priorityDir">
              <option value="asc" selected>数字越小越优先</option>
              <option value="desc">数字越大越优先</option>
            </select>
          </div>

          <div class="field">
            <label>亚马逊批次</label>
            <select id="amazonMode">
              <option value="60_40" selected>先60%滚一遍，再40%滚一遍</option>
              <option value="100">不分批（一次性全量）</option>
            </select>
          </div>

          <div class="field">
            <label>小平台优先</label>
            <select id="smallFirst">
              <option value="1" selected>是（先小平台）</option>
              <option value="0">否（按全局优先级混排）</option>
            </select>
          </div>

          <div class="field">
            <label>只允许同规格裂变</label>
            <select id="specStrict">
              <option value="1" selected>开（禁止跨规格补缺）</option>
              <option value="0">关（允许跨规格补缺：日缺口优先吃美结余）</option>
            </select>
          </div>

          <div class="field">
            <label>箱规取整</label>
            <select id="boxEnabled">
              <option value="1" selected>开（按箱规倍数向上取整）</option>
              <option value="0">关（不按箱规；仍保证整数）</option>
            </select>
          </div>

          <div class="field">
            <label>未分配站点名</label>
            <input id="unassignedSite" type="text" value="未分配/留库存" />
          </div>

          <div class="field">
            <label>合并同站点行</label>
            <select id="mergeOut">
              <option value="1" selected>是（推荐）</option>
              <option value="0">否</option>
            </select>
          </div>
        </div>

        <div class="row">
          <span id="status" class="sub">就绪：左边粘贴“需求明细”，右边粘贴“在途/库存明细”，然后点“生成裂变结果”。</span>
        </div>
      </div>

      <div class="hr"></div>

      <div class="tabs">
        <div class="tab active" data-tab="grid">表格粘贴（推荐）</div>
        <div class="tab" data-tab="excel">上传Excel</div>
      </div>

      <div id="panelGrid">
        <div class="grid">
          <div class="card">
            <div class="sheet-toolbar">
              <h3 style="margin:0">需求明细</h3>
              <div class="row">
                <button class="btn" id="btnAddDemandRows">追加50行</button>
                <button class="btn danger" id="btnClearDemand">清空需求</button>
              </div>
            </div>
            <div class="sheet-wrap"><div class="sheet-scroll"><table class="sheet" id="gridDemand"></table></div></div>
            <div class="sub">列固定：型号 / 颜色 / 站点（平台） / SI数量 / 品线 / 需求规格 / 平台 / 箱规信息 / 优先级</div>
          </div>

          <div class="card">
            <div class="sheet-toolbar">
              <h3 style="margin:0">在途 / 库存明细</h3>
              <div class="row">
                <button class="btn" id="btnAddSupplyRows">追加50行</button>
                <button class="btn danger" id="btnClearSupply">清空在途</button>
              </div>
            </div>
            <div class="sheet-wrap"><div class="sheet-scroll"><table class="sheet" id="gridSupply"></table></div></div>
            <div class="sub">列固定：销售采购订单号 / 物料编码 / 销售型号 / 颜色 / 规格 / 求和项:需求数量（上传Excel也兼容：仓库名称/自营销售型号/颜色简易版/充电器版本/求和项:可用量(主单位)）</div>
          </div>
        </div>
        <div class="footer-note">
          规则要点：<br/>
          1) 60/40 只对【亚马逊】行生效；小平台一次性全额满足（不做 60/40）。<br/>
          2) 60% 按优先级顺序逐行吃完一轮，再按优先级吃 40% 一轮。<br/>
          3) 60/40 每轮都“先同规格”，同规格不够且【只允许同规格裂变=关】时允许跨规格；需求=日优先吃美。<br/>
          4) 防止“两轮取整叠加超分”：每行有一个“整行目标(可按箱规取整)”，每轮计划量都按“剩余额度”封顶。<br/>
          5) 箱规取整开关：开=按箱规倍数向上取整；关=完全不走箱规倍数逻辑，但全程仍保证整数。
        </div>
      </div>

      <div id="panelExcel" class="hidden">
        <div class="grid">
          <div class="card">
            <h3 style="margin:0 0 10px 0">上传需求Excel</h3>
            <input id="fileDemand" type="file" accept=".xlsx,.xls" />
            <div class="sub">默认读取第一个sheet，表头需与页面列名一致。</div>
          </div>
          <div class="card">
            <h3 style="margin:0 0 10px 0">上传在途Excel</h3>
            <input id="fileSupply" type="file" accept=".xlsx,.xls" />
            <div class="sub">默认读取第一个sheet，支持两套表头（见左侧说明）。</div>
          </div>
        </div>
        <div class="footer-note">如果你看见“XLSX未定义”，说明没放本地 xlsx.full.min.js；用TSV下载也能导入。</div>
      </div>
    </div>

    <div class="card" style="margin-top:14px">
      <div class="row" style="justify-content:space-between">
        <h3 style="margin:0">裂变输出（导入用，=完整在途）</h3>
        <div class="row">
          <button class="btn" id="btnDownloadTSV" disabled>下载TSV</button>
          <button class="btn primary" id="btnDownloadXLSX" disabled>下载XLSX</button>
        </div>
      </div>
      <div class="sub">输出列：销售采购订单号 / 物料编码 / 销售型号 / 颜色 / 站点 / 规格 / 需求数量</div>
      <div class="hr"></div>
      <div id="outWrap" class="sub">还没有生成结果。</div>
    </div>

    <div class="card" style="margin-top:14px">
      <h3 style="margin:0">未满足需求（对账用）</h3>
      <div class="sub">这里展示“按规则分配后仍缺口”的行。</div>
      <div class="hr"></div>
      <div id="unmetWrap" class="sub">还没有生成结果。</div>
    </div>

    <div class="card" style="margin-top:14px">
      <h3 style="margin:0">在途剩余（对账用）</h3>
      <div class="sub">这张表会和“裂变输出”里【站点=未分配站点名】的数量一致（只是给你对账）。</div>
      <div class="hr"></div>
      <div id="leftWrap" class="sub">还没有生成结果。</div>
    </div>
  </div>

<script>
  const DEMAND_COLS = ["型号","颜色","站点（平台）","SI数量","品线","需求规格","平台","箱规信息","优先级"];
  const SUPPLY_COLS = ["销售采购订单号","物料编码","销售型号","颜色","规格","求和项:需求数量"];
  const OUT_COLS    = ["销售采购订单号","物料编码","销售型号","颜色","站点","规格","需求数量"];

  const $ = (id)=>document.getElementById(id);
  const state = { outRows: [], unmetRows: [], leftRows: [] };

  function setStatus(msg, ok=true){
    const el = $("status");
    el.textContent = msg;
    el.className = "sub " + (ok ? "ok" : "warn");
  }
  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }
  function toNum(v){
    const n = Number(String(v ?? "").replace(/,/g,"").trim());
    return Number.isFinite(n) ? n : 0;
  }
  // ✅数量统一整数（不允许出现小数）
  function toInt(v){
    return Math.max(0, Math.floor(toNum(v)));
  }
  // ✅箱规取整可开关：enabled=false 时不按箱规倍数，但仍返回整数
  function roundUpBox(qty, box, enabled=true){
    const q = Math.max(0, Math.ceil(toNum(qty))); // 先保证整数
    if(!enabled) return q;
    const b = toInt(box);
    if(b <= 0) return q;
    return Math.ceil(q / b) * b;
  }
  function normSpec(x){
    const s = String(x ?? "").trim();
    if(!s) return "";
    if(s.includes("日")) return "日";
    if(s.includes("美")) return "美";
    if(s.includes("欧")) return "欧";
    if(s.includes("英")) return "英";
    return s; // 例如 “无”
  }
  // ✅型号大小写归一：AnywiseW1Lite vs ANYWISEW1LITE 不再匹配失败
  function normKey(v){
    return String(v ?? "").trim().toUpperCase();
  }

  function buildGrid(tableId, columns, initialRows=50){
    const table = $(tableId);
    table.innerHTML = "";
    const thead = document.createElement("thead");
    const trh = document.createElement("tr");
    columns.forEach(c=>{
      const th = document.createElement("th");
      th.textContent = c;
      trh.appendChild(th);
    });
    thead.appendChild(trh);

    const tbody = document.createElement("tbody");
    for(let r=0;r<initialRows;r++){
      const tr = document.createElement("tr");
      for(let c=0;c<columns.length;c++){
        const td = document.createElement("td");
        const div = document.createElement("div");
        div.className = "cell";
        div.contentEditable = "true";
        div.dataset.r = String(r);
        div.dataset.c = String(c);
        div.addEventListener("paste", (e)=>onPasteIntoGrid(e, tableId, columns));
        td.appendChild(div);
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
    table.appendChild(thead);
    table.appendChild(tbody);
  }
  function addRows(tableId, columns, n=50){
    const table = $(tableId);
    const tbody = table.querySelector("tbody");
    const startR = tbody.children.length;
    for(let r=0;r<n;r++){
      const tr = document.createElement("tr");
      for(let c=0;c<columns.length;c++){
        const td = document.createElement("td");
        const div = document.createElement("div");
        div.className = "cell";
        div.contentEditable = "true";
        div.dataset.r = String(startR + r);
        div.dataset.c = String(c);
        div.addEventListener("paste", (e)=>onPasteIntoGrid(e, tableId, columns));
        td.appendChild(div);
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
  }
  function clearGrid(tableId){
    $(tableId).querySelectorAll(".cell").forEach(cell=>cell.textContent="");
  }
  function ensureRows(tableId, columns, needRows){
    const tbody = $(tableId).querySelector("tbody");
    const cur = tbody.children.length;
    if(needRows > cur) addRows(tableId, columns, needRows - cur);
  }
  function parseClipboardGrid(text){
    const rows = text.replace(/\r/g,"").split("\n");
    if(rows.length && rows[rows.length-1]==="") rows.pop();
    return rows.map(line => line.split("\t"));
  }
  function onPasteIntoGrid(e, tableId, columns){
    e.preventDefault();
    const text = (e.clipboardData || window.clipboardData).getData("text");
    const matrix = parseClipboardGrid(text);
    if(matrix.length===0) return;

    const active = document.activeElement;
    if(!active || !active.classList.contains("cell")) return;

    const r0 = Number(active.dataset.r);
    const c0 = Number(active.dataset.c);

    ensureRows(tableId, columns, r0 + matrix.length);

    const tbody = $(tableId).querySelector("tbody");
    for(let r=0;r<matrix.length;r++){
      const row = matrix[r];
      const tr = tbody.children[r0 + r];
      if(!tr) continue;
      const cells = tr.querySelectorAll(".cell");
      for(let c=0;c<row.length;c++){
        const tc = c0 + c;
        if(tc >= columns.length) break;
        cells[tc].textContent = row[c];
      }
    }
  }
  function readGridData(tableId, columns){
    const tbody = $(tableId).querySelector("tbody");
    const rows = [];
    for(const tr of tbody.children){
      const obj = {};
      let allEmpty = true;
      const cells = tr.querySelectorAll(".cell");
      columns.forEach((col, idx)=>{
        const v = (cells[idx]?.textContent ?? "").trim();
        obj[col] = v;
        if(v !== "") allEmpty = false;
      });
      if(!allEmpty) rows.push(obj);
    }
    return rows;
  }
  function fillGridFromObjects(tableId, columns, data){
    clearGrid(tableId);
    ensureRows(tableId, columns, Math.max(50, data.length));
    const tbody = $(tableId).querySelector("tbody");
    for(let r=0;r<data.length;r++){
      const tr = tbody.children[r];
      const cells = tr.querySelectorAll(".cell");
      for(let c=0;c<columns.length;c++){
        cells[c].textContent = data[r][columns[c]] ?? "";
      }
    }
  }

  function renderTable(containerId, rows){
    const wrap = $(containerId);
    if(!rows || rows.length===0){
      wrap.innerHTML = '<div class="sub">空</div>';
      return;
    }
    const cols = Object.keys(rows[0]);
    const thead = `<tr>${cols.map(c=>`<th>${escapeHtml(c)}</th>`).join("")}</tr>`;
    const tbody = rows.map(r=>`<tr>${cols.map(c=>`<td><div class="cell" style="border:0;box-shadow:none;background:#fff" contenteditable="false">${escapeHtml(String(r[c]??""))}</div></td>`).join("")}</tr>`).join("");
    wrap.innerHTML = `<div class="sheet-wrap"><div class="sheet-scroll" style="max-height:420px"><table class="sheet"><thead>${thead}</thead><tbody>${tbody}</tbody></table></div></div>`;
  }

  function rowsToTSV(rows, cols){
    if(!rows || rows.length===0) return "";
    const c = cols && cols.length ? cols : Object.keys(rows[0]);
    const lines = [];
    lines.push(c.join("\t"));
    for(const r of rows){
      lines.push(c.map(k => String(r[k]??"")).join("\t"));
    }
    return lines.join("\n");
  }
  function downloadText(filename, text, mime){
    const blob = new Blob([text], {type: mime});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }
  function enableDownloads(enabled){
    $("btnDownloadTSV").disabled = !enabled;
    $("btnDownloadXLSX").disabled = !enabled;
  }
  async function readExcelFile(file){
    if(!window.XLSX) throw new Error("XLSX库未加载：请把 xlsx.full.min.js 放到 html 同目录。");
    const buf = await file.arrayBuffer();
    const wb = XLSX.read(buf, {type:"array"});
    const ws = wb.Sheets[wb.SheetNames[0]];
    return XLSX.utils.sheet_to_json(ws, {defval:""});
  }

  function sortByPriority(rows, priorityDir){
    const asc = priorityDir === "asc";
    return [...rows].sort((a,b)=>{
      const ap = (a.__prio==null || a.__prio==="") ? Number.POSITIVE_INFINITY : Number(a.__prio);
      const bp = (b.__prio==null || b.__prio==="") ? Number.POSITIVE_INFINITY : Number(b.__prio);
      return asc ? (ap-bp) : (bp-ap);
    });
  }

  // ✅兼容两套供给表头：旧(销售型号/规格/需求数量) & 新(自营销售型号/充电器版本/可用量)
  function makeSupplyPool(supplyRows){
    return supplyRows.map((r, idx)=>({
      __idx: idx,
      order: (r["销售采购订单号"] ?? r["仓库名称"] ?? "").trim(),
      mat:   (r["物料编码"] ?? "").trim(),
      model: normKey(r["销售型号"] ?? r["自营销售型号"] ?? ""),
      color: (r["颜色"] ?? r["颜色简易版"] ?? "").trim(),
      spec:  normSpec(r["规格"] ?? r["充电器版本"] ?? ""),
      qtyLeft: toInt(r["求和项:需求数量"] ?? r["求和项:可用量(主单位)"] ?? 0),
    })).filter(x => x.order || x.mat || x.model || x.color || x.spec || x.qtyLeft);
  }

  function consumeFromSupply(pool, matchFn, qtyNeed){
    const allocs = [];
    let need = toInt(qtyNeed); // ✅强制整数
    if(need <= 0) return allocs;

    for(const s of pool){
      if(need <= 0) break;
      if(s.qtyLeft <= 0) continue;
      if(!matchFn(s)) continue;

      const take = Math.min(need, s.qtyLeft);
      s.qtyLeft -= take;
      need -= take;

      allocs.push({ order:s.order, mat:s.mat, model:s.model, color:s.color, spec:s.spec, qty:take });
    }
    return allocs;
  }

  function consolidateOut(rows){
    const m = new Map();
    for(const r of rows){
      const k = [r["销售采购订单号"], r["物料编码"], r["销售型号"], r["颜色"], r["站点"], r["规格"]].join("||");
      const cur = m.get(k) || { ...r, "需求数量": 0 };
      cur["需求数量"] = toInt(cur["需求数量"]) + toInt(r["需求数量"]);
      m.set(k, cur);
    }
    return Array.from(m.values());
  }

  function runAllocation(demandRowsRaw, supplyRowsRaw, opts){
    const {priorityDir, amazonMode, smallFirst, unassignedSite, mergeOut, specStrict, boxEnabled} = opts;
    const siteName = (unassignedSite || "未分配/留库存").trim() || "未分配/留库存";

    const demand = demandRowsRaw.map((r, idx)=>({
      __idx: idx,
      model: normKey(r["型号"]),
      color: (r["颜色"]??"").trim(),
      site: (r["站点（平台）"]??"").trim(),
      demandQty: toInt(r["SI数量"]),
      spec: normSpec(r["需求规格"]),
      platform: (r["平台"]??"").trim(), // 亚马逊 / 小平台
      box: toInt(r["箱规信息"]),
      __prio: (r["优先级"]??"").trim(),
    })).filter(d => d.model && d.site && d.spec);

    const supplyPool = makeSupplyPool(supplyRowsRaw);
    const demandAlloc = new Map();
    let out = [];

    function addOut(site, alloc){
      out.push({
        "销售采购订单号": alloc.order,
        "物料编码": alloc.mat,
        "销售型号": alloc.model,
        "颜色": alloc.color,
        "站点": site,
        "规格": alloc.spec,
        "需求数量": alloc.qty,
      });
    }
    function bump(dIdx, qty){
      demandAlloc.set(dIdx, (demandAlloc.get(dIdx)||0) + toInt(qty));
    }
    function got(d){ return demandAlloc.get(d.__idx) || 0; }
    function miss(d){ return Math.max(0, d.demandQty - got(d)); }

    // ✅分配一段数量：先同规格；若允许跨规格，则“日”优先吃“美”，然后再吃任意规格
    function allocQtyForDemand(d, qtyPlan, allowCrossSpec){
      let need = toInt(qtyPlan);
      if(need <= 0) return 0;

      // 1) 同规格优先
      const strictAllocs = consumeFromSupply(
        supplyPool,
        (s)=> s.model===d.model && s.color===d.color && s.spec===d.spec,
        need
      );
      for(const a of strictAllocs){ addOut(d.site, a); bump(d.__idx, a.qty); need -= a.qty; }
      if(need <= 0) return toInt(qtyPlan);

      if(!allowCrossSpec) return toInt(qtyPlan) - need;

      // 2) 日规缺口优先吃美规
      if(normSpec(d.spec) === "日"){
        const usFirst = consumeFromSupply(
          supplyPool,
          (s)=> s.model===d.model && s.color===d.color && normSpec(s.spec)==="美",
          need
        );
        for(const a of usFirst){ addOut(d.site, a); bump(d.__idx, a.qty); need -= a.qty; }
        if(need <= 0) return toInt(qtyPlan);
      }

      // 3) 其他规格兜底（同型号同颜色任意规格）
      const anySpec = consumeFromSupply(
        supplyPool,
        (s)=> s.model===d.model && s.color===d.color,
        need
      );
      for(const a of anySpec){ addOut(d.site, a); bump(d.__idx, a.qty); need -= a.qty; }
      return toInt(qtyPlan) - need;
    }

    function allocSmallPhase(smallSorted){
      // 小平台：一次性全额满足（不做 60/40）
      for(const d of smallSorted){
        const need = miss(d);
        if(need <= 0) continue;
        allocQtyForDemand(d, need, !specStrict);
      }

      // 小平台凑箱规补齐：按【型号+规格】汇总到箱规倍数；补齐量写入未分配（避免污染站点）
      const groupMap = new Map();
      for(const d of smallSorted){
        const key = d.model + "||" + d.spec;
        if(!groupMap.has(key)) groupMap.set(key, { box:d.box, rows:[] });
        groupMap.get(key).rows.push(d);
      }

      for(const [key, g] of groupMap.entries()){
        const [model, spec] = key.split("||");
        const total = g.rows.reduce((a,d)=>a + got(d), 0);
        const target = roundUpBox(total, g.box, boxEnabled);
        let needExtra = toInt(target - total);
        if(needExtra <= 0) continue;

        const allocs = consumeFromSupply(
          supplyPool,
          (s)=> s.model===model && s.spec===spec,
          needExtra
        );
        for(const a of allocs){
          out.push({
            "销售采购订单号": a.order,
            "物料编码": a.mat,
            "销售型号": a.model,
            "颜色": a.color,
            "站点": siteName,
            "规格": a.spec,
            "需求数量": a.qty
          });
          needExtra -= a.qty;
        }
      }
    }

    function allocAmazonPhase(amazonSorted){
      // ✅亚马逊：60%一轮（按优先级），再40%一轮（按优先级）
      // ✅每轮：先同规格；同规格不够且 specStrict=关 时允许跨规格（日优先吃美）
      // ✅防止 32→40：每行有整行目标(可按箱规)，每轮计划量按“剩余额度”封顶
      function allocAmazonOnce(d, plannedQty){
        const targetTotal = roundUpBox(d.demandQty, d.box, boxEnabled);
        const remain = toInt(targetTotal - got(d));
        if(remain <= 0) return;

        const planRounded = roundUpBox(plannedQty, d.box, boxEnabled);
        const plan = Math.min(toInt(planRounded), remain);
        if(plan <= 0) return;

        allocQtyForDemand(d, plan, !specStrict);
      }

      if(amazonMode === "100"){
        for(const d of amazonSorted){ allocAmazonOnce(d, d.demandQty); }
        return;
      }
      for(const d of amazonSorted){ allocAmazonOnce(d, Math.ceil(d.demandQty * 0.6)); }
      for(const d of amazonSorted){ allocAmazonOnce(d, Math.ceil(d.demandQty * 0.4)); }
    }

    function allocOtherPhase(otherSorted){
      for(const d of otherSorted){
        const need = miss(d);
        if(need <= 0) continue;
        allocQtyForDemand(d, need, !specStrict);
      }
    }

    const small  = demand.filter(d => d.platform === "小平台");
    const amazon = demand.filter(d => d.platform === "亚马逊");
    const other  = demand.filter(d => d.platform !== "小平台" && d.platform !== "亚马逊");

    const smallSorted  = sortByPriority(small, priorityDir);
    const amazonSorted = sortByPriority(amazon, priorityDir);
    const otherSorted  = sortByPriority(other, priorityDir);

    if(smallFirst){
      allocSmallPhase(smallSorted);
      allocAmazonPhase(amazonSorted);
      allocOtherPhase(otherSorted);
    }else{
      allocSmallPhase(smallSorted);
      allocAmazonPhase(amazonSorted);
      allocOtherPhase(otherSorted);
    }

    const unmetFinal = [];
    for(const d of demand){
      const m = miss(d);
      if(m > 0){
        unmetFinal.push({
          "型号": d.model, "颜色": d.color, "站点": d.site, "规格": d.spec, "平台": d.platform,
          "原需求": d.demandQty, "已分配": got(d), "仍缺口": m, "优先级": d.__prio, "箱规": d.box
        });
      }
    }

    const left = supplyPool.filter(s => s.qtyLeft > 0).map(s => ({
      "销售采购订单号": s.order,
      "物料编码": s.mat,
      "销售型号": s.model,
      "颜色": s.color,
      "规格": s.spec,
      "剩余数量": s.qtyLeft
    }));

    // 把剩余追加进裂变输出，保证“裂变输出=完整库存/在途总量”
    for(const s of supplyPool){
      if(s.qtyLeft > 0){
        out.push({
          "销售采购订单号": s.order,
          "物料编码": s.mat,
          "销售型号": s.model,
          "颜色": s.color,
          "站点": siteName,
          "规格": s.spec,
          "需求数量": s.qtyLeft
        });
      }
    }

    if(mergeOut){
      out = consolidateOut(out);
    }

    return { out, unmet: unmetFinal, left };
  }

  document.querySelectorAll(".tab").forEach(t=>{
    t.addEventListener("click", ()=>{
      document.querySelectorAll(".tab").forEach(x=>x.classList.remove("active"));
      t.classList.add("active");
      const tab = t.dataset.tab;
      $("panelGrid").classList.toggle("hidden", tab!=="grid");
      $("panelExcel").classList.toggle("hidden", tab!=="excel");
      setStatus("切换模式完成。", true);
    });
  });

  buildGrid("gridDemand", DEMAND_COLS, 50);
  buildGrid("gridSupply", SUPPLY_COLS, 50);

  $("btnAddDemandRows").addEventListener("click", ()=>addRows("gridDemand", DEMAND_COLS, 50));
  $("btnAddSupplyRows").addEventListener("click", ()=>addRows("gridSupply", SUPPLY_COLS, 50));
  $("btnClearDemand").addEventListener("click", ()=>clearGrid("gridDemand"));
  $("btnClearSupply").addEventListener("click", ()=>clearGrid("gridSupply"));

  $("btnClearAll").addEventListener("click", ()=>{
    clearGrid("gridDemand"); clearGrid("gridSupply");
    $("fileDemand").value=""; $("fileSupply").value="";
    $("outWrap").innerHTML = '<div class="sub">还没有生成结果。</div>';
    $("unmetWrap").innerHTML = '<div class="sub">还没有生成结果。</div>';
    $("leftWrap").innerHTML = '<div class="sub">还没有生成结果。</div>';
    enableDownloads(false);
    setStatus("已清空。", true);
  });

  $("btnLoadSample").addEventListener("click", ()=>{
    fillGridFromObjects("gridDemand", DEMAND_COLS, [
      {"型号":"AP12","颜色":"蓝色","站点（平台）":"UK","SI数量":"32","品线":"智能平板","需求规格":"欧","平台":"亚马逊","箱规信息":"8","优先级":"12"},
      {"型号":"AP12","颜色":"蓝色","站点（平台）":"DE","SI数量":"32","品线":"智能平板","需求规格":"欧","平台":"亚马逊","箱规信息":"8","优先级":"99"},
      {"型号":"AP12","颜色":"蓝色","站点（平台）":"JP","SI数量":"32","品线":"智能平板","需求规格":"日","平台":"亚马逊","箱规信息":"8","优先级":"50"},
      {"型号":"AP12","颜色":"蓝色","站点（平台）":"TEMU","SI数量":"20","品线":"智能平板","需求规格":"欧","平台":"小平台","箱规信息":"8","优先级":"6"}
    ]);
    fillGridFromObjects("gridSupply", SUPPLY_COLS, [
      {"销售采购订单号":"PO1","物料编码":"M1","销售型号":"AP12","颜色":"蓝色","规格":"欧","求和项:需求数量":"40"},
      {"销售采购订单号":"PO2","物料编码":"M2","销售型号":"AP12","颜色":"蓝色","规格":"美","求和项:需求数量":"20"},
      {"销售采购订单号":"PO3","物料编码":"M3","销售型号":"AP12","颜色":"蓝色","规格":"日","求和项:需求数量":"8"}
    ]);
    setStatus("已载入示例：箱规取整可开关；specStrict关时日缺口可优先吃美。", true);
  });

  async function loadExcelToGrid(){
    const fD = $("fileDemand").files[0];
    const fS = $("fileSupply").files[0];
    if(!fD || !fS) throw new Error("请同时上传需求Excel和在途Excel。");

    const demJson = await readExcelFile(fD);
    const supJson = await readExcelFile(fS);

    const dem = demJson.map(r=>{ const o={}; DEMAND_COLS.forEach(c=>o[c]=r[c]??""); return o; })
                       .filter(r=>DEMAND_COLS.some(c=>String(r[c]??"").trim()!==""));

    // 供给表头：保留“新表头字段”到对象里，makeSupplyPool 会识别
    const sup = supJson.map(r=>{
      const o = {};
      SUPPLY_COLS.forEach(c=>o[c]=r[c]??"");
      o["仓库名称"] = r["仓库名称"] ?? "";
      o["自营销售型号"] = r["自营销售型号"] ?? "";
      o["颜色简易版"] = r["颜色简易版"] ?? "";
      o["充电器版本"] = r["充电器版本"] ?? "";
      o["求和项:可用量(主单位)"] = r["求和项:可用量(主单位)"] ?? "";
      o["规格"] = r["规格"] ?? o["规格"] ?? "";
      o["求和项:需求数量"] = r["求和项:需求数量"] ?? o["求和项:需求数量"] ?? "";
      o["销售型号"] = r["销售型号"] ?? o["销售型号"] ?? "";
      o["颜色"] = r["颜色"] ?? o["颜色"] ?? "";
      o["销售采购订单号"] = r["销售采购订单号"] ?? o["销售采购订单号"] ?? "";
      o["物料编码"] = r["物料编码"] ?? o["物料编码"] ?? "";
      return o;
    }).filter(r=>{
      return Object.keys(r).some(k=>String(r[k]??"").trim()!=="");
    });

    fillGridFromObjects("gridDemand", DEMAND_COLS, dem);

    // 只把页面6列回填到页面表格（上传模式实际用的是 sup 原对象）
    fillGridFromObjects("gridSupply", SUPPLY_COLS, sup.map(r=>{
      const o={}; SUPPLY_COLS.forEach(c=>o[c]=r[c]??""); return o;
    }));
    return {dem, sup};
  }

  $("btnRun").addEventListener("click", async ()=>{
    try{
      enableDownloads(false);

      const priorityDir = $("priorityDir").value;
      const amazonMode = $("amazonMode").value;
      const smallFirst = $("smallFirst").value === "1";
      const specStrict = $("specStrict").value === "1";
      const boxEnabled = $("boxEnabled").value === "1";
      const unassignedSite = ($("unassignedSite").value || "未分配/留库存").trim();
      const mergeOut = $("mergeOut").value === "1";

      const activeTab = document.querySelector(".tab.active").dataset.tab;

      let demRows = [];
      let supRows = [];

      if(activeTab === "excel"){
        const res = await loadExcelToGrid();
        demRows = res.dem; supRows = res.sup;
      }else{
        demRows = readGridData("gridDemand", DEMAND_COLS);
        supRows = readGridData("gridSupply", SUPPLY_COLS);
      }

      if(demRows.length===0) throw new Error("需求明细为空。");
      if(supRows.length===0) throw new Error("在途/库存明细为空。");

      const {out, unmet, left} = runAllocation(demRows, supRows, {
        priorityDir, amazonMode, smallFirst, unassignedSite, mergeOut, specStrict, boxEnabled
      });

      state.outRows = out;
      state.unmetRows = unmet;
      state.leftRows = left;

      renderTable("outWrap", out.length? out : [{"提示":"没有产生任何分配（可能在途为0或匹配不到）"}]);
      renderTable("unmetWrap", unmet.length? unmet : [{"提示":"没有未满足需求"}]);
      renderTable("leftWrap", left.length? left : [{"提示":"没有在途剩余"}]);

      enableDownloads(true);

      const outSum = out.reduce((a,r)=>a + toInt(r["需求数量"]), 0);
      const leftSum = left.reduce((a,r)=>a + toInt(r["剩余数量"]), 0);
      setStatus(`完成：裂变输出${out.length}行(合计${outSum})；未满足${unmet.length}行；在途剩余${left.length}行(合计${leftSum})。`, true);

    }catch(e){
      console.error(e);
      setStatus("失败：" + (e?.message || String(e)), false);
      $("outWrap").innerHTML = '<div class="sub warn">生成失败：检查列名是否一致、平台是否写“亚马逊/小平台”、规格是否一致（欧/英/日/美/无），以及在途数量列是否为数字。</div>';
      $("unmetWrap").innerHTML = '<div class="sub warn">生成失败。</div>';
      $("leftWrap").innerHTML = '<div class="sub warn">生成失败。</div>';
      enableDownloads(false);
    }
  });

  $("btnDownloadTSV").addEventListener("click", ()=>{
    if(!state.outRows.length) return;
    const tsv = rowsToTSV(state.outRows, OUT_COLS);
    downloadText("在途分货裂变_裂变输出.tsv", tsv, "text/tab-separated-values;charset=utf-8");
  });

  $("btnDownloadXLSX").addEventListener("click", ()=>{
    if(!state.outRows.length) return;
    if(!window.XLSX){
      setStatus("XLSX库未加载：请把 xlsx.full.min.js 放到 html 同目录；或用TSV下载。", false);
      return;
    }
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(state.outRows), "裂变输出");
    XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(state.unmetRows), "未满足需求");
    XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(state.leftRows), "在途剩余");

    const buf = XLSX.write(wb, { bookType:"xlsx", type:"array" });
    const blob = new Blob([buf], { type:"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "在途分货裂变_结果.xlsx";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });
</script>
</body>
</html>
